<!doctype html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="ol/ol.css" type="text/css">
    <style>
      .map {
        height: 500px;
        width: 500px;
      }
    </style>
    <script src="ol/ol.js" type="text/javascript"></script>
    <title>Oxyfi Trains</title>
  </head>
  <body>
    <h2>Karta</h2>
    <button onclick="follow = false;">stop</button>
    <p id="traininfo"></p>
    <p id="trainmax"></p>
    <div id="map" class="map"></div>
    <table id="list"></table>
    <script>

// Author: Arnold Andreasson, info@mellifica.se
// Copyright (c) 2007-2016 Arnold Andreasson 
// License: MIT License as follows:
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// =============================================================================
// Javascript-implementation of "Gauss Conformal Projection 
// (Transverse Mercator), KrÃ¼gers Formulas".
// - Parameters for SWEREF99 lat-long to/from RT90 and SWEREF99 
//   coordinates (RT90 and SWEREF99 are used in Swedish maps).
// Source: http://www.lantmateriet.se/geodesi/
 
var axis = null; // Semi-major axis of the ellipsoid.
var flattening = null; // Flattening of the ellipsoid.
var central_meridian = null; // Central meridian for the projection.
var lat_of_origin = null; // Latitude of origin.
var scale = null; // Scale on central meridian.
var false_northing = null; // Offset for origo.
var false_easting = null; // Offset for origo.

// Parameters for RT90 and SWEREF99TM.
// Note: Parameters for RT90 are choosen to eliminate the 
// differences between Bessel and GRS80-ellipsoides.
// Bessel-variants should only be used if lat/long are given as
// RT90-lat/long based on the Bessel ellipsoide (from old maps).
// Parameter: projection (string). Must match if-statement.
function swedish_params(projection) {
	// RT90 parameters, GRS 80 ellipsoid.
	if (projection == "rt90_7.5_gon_v") {
		grs80_params();
		central_meridian = 11.0 + 18.375/60.0;
		scale = 1.000006000000;
		false_northing = -667.282;
		false_easting = 1500025.141;
	}
	else if (projection == "rt90_5.0_gon_v") {
		grs80_params();
		central_meridian = 13.0 + 33.376/60.0;
		scale = 1.000005800000;
		false_northing = -667.130;
		false_easting = 1500044.695;
	}
	else if (projection == "rt90_2.5_gon_v") {
		grs80_params();
		central_meridian = 15.0 + 48.0/60.0 + 22.624306/3600.0;
		scale = 1.00000561024;
		false_northing = -667.711;
		false_easting = 1500064.274;
	}
	else if (projection == "rt90_0.0_gon_v") {
		grs80_params();
		central_meridian = 18.0 + 3.378/60.0;
		scale = 1.000005400000;
		false_northing = -668.844;
		false_easting = 1500083.521;
	}
	else if (projection == "rt90_2.5_gon_o") {
		grs80_params();
		central_meridian = 20.0 + 18.379/60.0;
		scale = 1.000005200000;
		false_northing = -670.706;
		false_easting = 1500102.765;
	}
	else if (projection == "rt90_5.0_gon_o") {
		grs80_params();
		central_meridian = 22.0 + 33.380/60.0;
		scale = 1.000004900000;
		false_northing = -672.557;
		false_easting = 1500121.846;
	}
	
	// RT90 parameters, Bessel 1841 ellipsoid.
	else if (projection == "bessel_rt90_7.5_gon_v") {
		bessel_params();
		central_meridian = 11.0 + 18.0/60.0 + 29.8/3600.0;
	}
	else if (projection == "bessel_rt90_5.0_gon_v") {
		bessel_params();
		central_meridian = 13.0 + 33.0/60.0 + 29.8/3600.0;
	}
	else if (projection == "bessel_rt90_2.5_gon_v") {
		bessel_params();
		central_meridian = 15.0 + 48.0/60.0 + 29.8/3600.0;
	}
	else if (projection == "bessel_rt90_0.0_gon_v") {
		bessel_params();
		central_meridian = 18.0 + 3.0/60.0 + 29.8/3600.0;
	}
	else if (projection == "bessel_rt90_2.5_gon_o") {
		bessel_params();
		central_meridian = 20.0 + 18.0/60.0 + 29.8/3600.0;
	}
	else if (projection == "bessel_rt90_5.0_gon_o") {
		bessel_params();
		central_meridian = 22.0 + 33.0/60.0 + 29.8/3600.0;
	}

	// SWEREF99TM and SWEREF99ddmm  parameters.
	else if (projection == "sweref_99_tm") {
		sweref99_params();
		central_meridian = 15.00;
		lat_of_origin = 0.0;
		scale = 0.9996;
		false_northing = 0.0;
		false_easting = 500000.0;
	}
	else if (projection == "sweref_99_1200") {
		sweref99_params();
		central_meridian = 12.00;
	}
	else if (projection == "sweref_99_1330") {
		sweref99_params();
		central_meridian = 13.50;
	}
	else if (projection == "sweref_99_1500") {
		sweref99_params();
		central_meridian = 15.00;
	}
	else if (projection == "sweref_99_1630") {
		sweref99_params();
		central_meridian = 16.50;
	}
	else if (projection == "sweref_99_1800") {
		sweref99_params();
		central_meridian = 18.00;
	}
	else if (projection == "sweref_99_1415") {
		sweref99_params();
		central_meridian = 14.25;
	}
	else if (projection == "sweref_99_1545") {
		sweref99_params();
		central_meridian = 15.75;
	}
	else if (projection == "sweref_99_1715") {
		sweref99_params();
		central_meridian = 17.25;
	}
	else if (projection == "sweref_99_1845") {
		sweref99_params();
		central_meridian = 18.75;
	}
	else if (projection == "sweref_99_2015") {
		sweref99_params();
		central_meridian = 20.25;
	}
	else if (projection == "sweref_99_2145") {
		sweref99_params();
		central_meridian = 21.75;
	}
	else if (projection == "sweref_99_2315") {
		sweref99_params();
		central_meridian = 23.25;
	}

	// Test-case:
	//	Lat: 66 0'0", lon: 24 0'0".
	//	X:1135809.413803 Y:555304.016555.
	else if (projection == "test_case") {
		axis = 6378137.0;
		flattening = 1.0 / 298.257222101;
		central_meridian = 13.0 + 35.0/60.0 + 7.692000/3600.0;
		lat_of_origin = 0.0;
		scale = 1.000002540000;
		false_northing = -6226307.8640;
		false_easting = 84182.8790;

	// Not a valid projection.		
	} else {
		central_meridian = null;
	}
}
// Sets of default parameters.
function grs80_params() {
	axis = 6378137.0; // GRS 80.
	flattening = 1.0 / 298.257222101; // GRS 80.
	central_meridian = null;
	lat_of_origin = 0.0;
}
function bessel_params() {
	axis = 6377397.155; // Bessel 1841.
	flattening = 1.0 / 299.1528128; // Bessel 1841.
	central_meridian = null;
	lat_of_origin = 0.0;
	scale = 1.0;
	false_northing = 0.0;
	false_easting = 1500000.0;
}
function sweref99_params() {
	axis = 6378137.0; // GRS 80.
	flattening = 1.0 / 298.257222101; // GRS 80.
	central_meridian = null;
	lat_of_origin = 0.0;
	scale = 1.0;
	false_northing = 0.0;
	false_easting = 150000.0;
}

// Conversion from geodetic coordinates to grid coordinates.
function geodetic_to_grid(latitude, longitude) {
	var x_y = new Array(2);
	if (central_meridian == null) {
		return x_y;
	}
	// Prepare ellipsoid-based stuff.
	var e2 = flattening * (2.0 - flattening);
	var n = flattening / (2.0 - flattening);
	var a_roof = axis / (1.0 + n) * (1.0 + n*n/4.0 + n*n*n*n/64.0);
	var A = e2;
	var B = (5.0*e2*e2 - e2*e2*e2) / 6.0;
	var C = (104.0*e2*e2*e2 - 45.0*e2*e2*e2*e2) / 120.0;
	var D = (1237.0*e2*e2*e2*e2) / 1260.0;
	var beta1 = n/2.0 - 2.0*n*n/3.0 + 5.0*n*n*n/16.0 + 41.0*n*n*n*n/180.0;
	var beta2 = 13.0*n*n/48.0 - 3.0*n*n*n/5.0 + 557.0*n*n*n*n/1440.0;
	var beta3 = 61.0*n*n*n/240.0 - 103.0*n*n*n*n/140.0;
	var beta4 = 49561.0*n*n*n*n/161280.0;
	
	// Convert.
	var deg_to_rad = Math.PI / 180.0;
	var phi = latitude * deg_to_rad;
	var lambda = longitude * deg_to_rad;
	var lambda_zero = central_meridian * deg_to_rad;
	
	var phi_star = phi - Math.sin(phi) * Math.cos(phi) * (A + 
					B*Math.pow(Math.sin(phi), 2) + 
					C*Math.pow(Math.sin(phi), 4) + 
					D*Math.pow(Math.sin(phi), 6));
	var delta_lambda = lambda - lambda_zero;
	var xi_prim = Math.atan(Math.tan(phi_star) / Math.cos(delta_lambda));
	var eta_prim = math_atanh(Math.cos(phi_star) * Math.sin(delta_lambda));
	var x = scale * a_roof * (xi_prim +
					beta1 * Math.sin(2.0*xi_prim) * math_cosh(2.0*eta_prim) +
					beta2 * Math.sin(4.0*xi_prim) * math_cosh(4.0*eta_prim) +
					beta3 * Math.sin(6.0*xi_prim) * math_cosh(6.0*eta_prim) +
					beta4 * Math.sin(8.0*xi_prim) * math_cosh(8.0*eta_prim)) + 
					false_northing;
	var y = scale * a_roof * (eta_prim +
					beta1 * Math.cos(2.0*xi_prim) * math_sinh(2.0*eta_prim) +
					beta2 * Math.cos(4.0*xi_prim) * math_sinh(4.0*eta_prim) +
					beta3 * Math.cos(6.0*xi_prim) * math_sinh(6.0*eta_prim) +
					beta4 * Math.cos(8.0*xi_prim) * math_sinh(8.0*eta_prim)) + 
					false_easting;
	x_y[0] = Math.round(x * 1000.0) / 1000.0;
	x_y[1] = Math.round(y * 1000.0) / 1000.0;
	return x_y;
}

// Conversion from grid coordinates to geodetic coordinates.
function grid_to_geodetic(x, y) {
	var lat_lon = new Array(2);
	if (central_meridian == null) {
		return lat_lon;
	}
	// Prepare ellipsoid-based stuff.
	var e2 = flattening * (2.0 - flattening);
	var n = flattening / (2.0 - flattening);
	var a_roof = axis / (1.0 + n) * (1.0 + n*n/4.0 + n*n*n*n/64.0);
	var delta1 = n/2.0 - 2.0*n*n/3.0 + 37.0*n*n*n/96.0 - n*n*n*n/360.0;
	var delta2 = n*n/48.0 + n*n*n/15.0 - 437.0*n*n*n*n/1440.0;
	var delta3 = 17.0*n*n*n/480.0 - 37*n*n*n*n/840.0;
	var delta4 = 4397.0*n*n*n*n/161280.0;
	
	var Astar = e2 + e2*e2 + e2*e2*e2 + e2*e2*e2*e2;
	var Bstar = -(7.0*e2*e2 + 17.0*e2*e2*e2 + 30.0*e2*e2*e2*e2) / 6.0;
	var Cstar = (224.0*e2*e2*e2 + 889.0*e2*e2*e2*e2) / 120.0;
	var Dstar = -(4279.0*e2*e2*e2*e2) / 1260.0;

	// Convert.
	var deg_to_rad = Math.PI / 180;
	var lambda_zero = central_meridian * deg_to_rad;
	var xi = (x - false_northing) / (scale * a_roof);		
	var eta = (y - false_easting) / (scale * a_roof);
	var xi_prim = xi - 
					delta1*Math.sin(2.0*xi) * math_cosh(2.0*eta) - 
					delta2*Math.sin(4.0*xi) * math_cosh(4.0*eta) - 
					delta3*Math.sin(6.0*xi) * math_cosh(6.0*eta) - 
					delta4*Math.sin(8.0*xi) * math_cosh(8.0*eta);
	var eta_prim = eta - 
					delta1*Math.cos(2.0*xi) * math_sinh(2.0*eta) - 
					delta2*Math.cos(4.0*xi) * math_sinh(4.0*eta) - 
					delta3*Math.cos(6.0*xi) * math_sinh(6.0*eta) - 
					delta4*Math.cos(8.0*xi) * math_sinh(8.0*eta);
	var phi_star = Math.asin(Math.sin(xi_prim) / math_cosh(eta_prim));
	var delta_lambda = Math.atan(math_sinh(eta_prim) / Math.cos(xi_prim));
	var lon_radian = lambda_zero + delta_lambda;
	var lat_radian = phi_star + Math.sin(phi_star) * Math.cos(phi_star) * 
					(Astar + 
					 Bstar*Math.pow(Math.sin(phi_star), 2) + 
					 Cstar*Math.pow(Math.sin(phi_star), 4) + 
					 Dstar*Math.pow(Math.sin(phi_star), 6));  	
	lat_lon[0] = lat_radian * 180.0 / Math.PI;
	lat_lon[1] = lon_radian * 180.0 / Math.PI;
	return lat_lon;
}

// Missing functions in the Math library.
function math_sinh(value) {
	return 0.5 * (Math.exp(value) - Math.exp(-value));
}
function math_cosh(value) {
	return 0.5 * (Math.exp(value) + Math.exp(-value));
}
function math_atanh(value) {
	return 0.5 * Math.log((1.0 + value) / (1.0 - value));
}
swedish_params("sweref_99_tm");

    
    function append(id, string){
        document.getElementById(id).innerHTML = document.getElementById(id).innerHTML + string;
    }
    
    function readgprmc(cvsline){

        // Split buy comma
        data = cvsline.split(",");

        // Calculate speed
        speed = Math.round(parseFloat(data[7])*185.2)/100.0;

        // Change degmin to decimal degrees
        deglat = parseFloat(data[3].substring(0, 2));
        minlat = parseFloat(data[3].substring(2));
        deglat = deglat + (minlat / 60);

        deglon = parseFloat(data[5].substring(0, 3));
        minlon = parseFloat(data[5].substring(3));
        deglon = deglon + (minlon / 60);

        // Get Train ids
        trainids = data[16].split(';');
        if (trainids = data[16]){
            trainids = [trainids];
        }

        // Get direction if not set return false
        direction = false;
        if (data[8] !== ''){
            direction  = parseFloat(data[8]);
        }
        
        // Return data to user
        return {
            "time":data[1],
            "date":data[9],
            "direction":direction,
            "position":[deglon,deglat],
            "speed":speed,
            "vehicle":data[14],
            "trainids":trainids
            };
    }

      var url="tiles/{z}/{x}/{y}.png";
      var follow = '';
      var position = {};
      var list = {};
      var poslayer = new ol.source.Vector({});
      var map = new ol.Map({
        target: 'map',
        layers: [
          new ol.layer.Tile({
            source: new ol.source.OSM()
            //source: new ol.source.OSM({url : url})
          }),
          new ol.layer.Vector({
          source: poslayer
          })
        ],
        view: new ol.View({
          center: ol.proj.fromLonLat([16.2, 62.3]),
          zoom: 4,
          minZoom: 4,
          maxZoom: 14
        })
      });
      
var style = new ol.style.Style({
    image: new ol.style.Circle({
        fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0.7)'
        }),
        stroke: new ol.style.Stroke({
            width: 1,
            color: 'rgba(255, 150, 0, 1)'
        }),
        radius: 7
    })
});

      var Socket = new WebSocket('wss://api.oxyfi.com/trainpos/listen?v=1&key=e6ab725a30ef45f6a38c3a9b83f5f65a');
Socket.onmessage = function (data){
    data = readgprmc(data.data);

    if (data["speed"] > 5.0 || list[data['vehicle']] == undefined){
    var point = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.transform(data["position"], 'EPSG:4326', 'EPSG:3857')),
        name: data['vehicle']
    });
    
    point.setStyle(style);
    
    if(position[data['vehicle']] == undefined){
        position[data['vehicle']] = point;
        poslayer.addFeature(position[data["vehicle"]]);
    }
    
    position[data['vehicle']].setGeometry(new ol.geom.Point(ol.proj.transform(data["position"], 'EPSG:4326', 'EPSG:3857')));
    
    if(follow == data['vehicle']){
        document.getElementById('traininfo').innerHTML = data["speed"] + " km/h <br>" + 
                                                    data["trainids"][0].replace(";","<br>") + "";
        map.getView().setCenter(ol.proj.transform(data["position"], 'EPSG:4326', 'EPSG:3857'));
        getLimit(data["position"]);
    }
    
    }

    if( list[data['vehicle']] == undefined){
        list[data['vehicle']] = {"pos":data["position"]}
        append('list', '<tr><td onclick="setMapCenter(\''+data['vehicle']+'\')">'+data['vehicle'] +'</td> <td id="'+data['vehicle']+'"></td> <td>'+data["trainids"][0]+'</td></tr>');
    }
    document.getElementById(data['vehicle']).innerHTML = speed + " km/h";
    list[data['vehicle']]["pos"] = data["position"];
}

function setMapCenter(train){
        follow = train;
        getPosition(list[train]['pos']);
        map.getView().setCenter(ol.proj.transform(list[train]['pos'], 'EPSG:4326', 'EPSG:3857'));
    }

function getLimit(pos){
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://192.168.60.11:9264/'+pos[0]+'/'+pos[1]);
    xhr.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
       document.getElementById('trainmax').innerHTML = '';
       JSON.parse(this.responseText).speeds.forEach(showmaxspeeds);
    }
    };
    xhr.send();
}

function showmaxspeeds(data, index){
       append('trainmax', data + " <br>")
}

function getPosition(pos){
    pos = geodetic_to_grid(pos[1], pos[0]);
    pos = pos[1]+" "+ pos[0];
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'http://api.trafikinfo.trafikverket.se/v1.1/data.json');
    xhr.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
       stopid = JSON.parse(this.responseText).RESPONSE.RESULT[0].TrainStation[0].LocationSignature;
       getDepartures(stopid);
    }
    };
    xhr.setRequestHeader('Content-Type', 'text/xml');
    xhr.send('<REQUEST><LOGIN authenticationkey="bd08e0c825154775a9c860ee8e08ed05" /><QUERY objecttype="TrainStation"><FILTER><WITHIN name="Geometry.SWEREF99TM" shape="center" value="'+pos+'" radius="1000" /></FILTER></QUERY></REQUEST>');
    }
    
function getDepartures(stop){
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'http://api.trafikinfo.trafikverket.se/v1.1/data.json');
    xhr.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
       console.log(JSON.parse(this.responseText));
    }
    };
    xhr.setRequestHeader('Content-Type', 'text/xml');
    xhr.send('<REQUEST><LOGIN authenticationkey="bd08e0c825154775a9c860ee8e08ed05" /><QUERY objecttype="TrainAnnouncement" orderby="AdvertisedTimeAtLocation"><FILTER><EQ name="ActivityType" value="Avgang" /><EQ name="LocationSignature" value="'+stop+'" /><GT name="TimeAtLocation" value="$dateadd(-0.00:10:00)" /></FILTER></QUERY></REQUEST>');

}
    </script>
  </body>
</html>